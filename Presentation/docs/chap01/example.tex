\begin{frame}{مثال : مسئله}
مسئله کوتاهترین مسیر بین دو شهر
\m{c_x}
و
\m{c_y}
تشکیل شده است از شرحی از پارامتر های مسئله یعنی:
\begin{itemize}\itmsep{2mm}
\item[-]
مجموعه ای از شهرها،
\m{C = \{ c_1, c_2, ..., c_m \}}
\item[-]
مجموعه ای از جاده‌ها، به طوری که هر جاده دو شهر را به هم متصل می‌کند،
\m{R \subseteq C \times C}
\item[-]
تابعی که به ازای هر دو شهر به هم متصل شده توسط یک جاده، طول جاده مشخص می‌کند،
\m{len : R \rightarrow \NN}
\end{itemize}

و همچنین شرحی از جواب مسئله یعنی:
\begin{itemize}\itmsep{5mm}
\item[-]
مسیر
\m{P = \langle c_{f(1)}, c_{f(2)}, ..., c_{f(n)} \rangle}
با
\m{f(1) = x}
،
\m{f(n) = y}
،
\m{1 < n \leq m}
وجود داشته باشد، به طوری که
مقدار پارامتر
\m{L}
 کمینه باشد.

\begin{center}
\m{L = \sum_{i=1}^{n-1} len(c_{f(i)}, c_{f(i+1)})}
\end{center}

\end{itemize}
\end{frame}

\begin{frame}{مثال : نمونهٔ مسئله}
کوتاهترین مسیر بین دو شهر
\m{c_1}
و
\m{c_5}
را پیدا کنید به طوری که
\begin{align*}
\m{C} =~& \m{ \{ c_1, c_2, c_3, c_4, c_5 \}} \\
\m{R} =~& \m{\{ (c_1, c_2), (c_1,c_3), (c_2, c_3), (c_2, c_4), (c_3, c_4), (c_3, c_5), (c_4, c_5) \}} \\
\m{len} =~& \m{\{ ((c_1, c_2),2), ((c_1,c_3),5), ((c_2, c_3),1), ((c_2, c_4),6),}  \\
~& \m{((c_3, c_4),4), ((c_3, c_5),8), ((c_4, c_5),3) \}}
\end{align*}

\begin{figure}[!ht]
  \centering
  \includestandalone{figs/chap01/g1}
  \label{fig:g1}
\end{figure}

\end{frame}

\begin{frame}{مثال : یک الگوریتم ساده برای مسئله کوتاهترین مسیر}
\begin{itemize}\itmsep{2mm}
\item[1] همهٔ مسیرها از 
\m{c_x}
به
\m{c_y}
را پیدا می‌کنیم.
\item[2]
طول همهٔ آن مسیرها را محاسبه می‌کنیم.
\item[3]
کوتاهترین مسیر را به دست می‌آوریم.
\end{itemize}
\end{frame}

\begin{frame}{تابع پیچیدگی زمانی}

\begin{itemize}\itmsep{5mm}
\item[-]
تابع پیچیدگی زمانی برای یک الگویتم، زمان (و یا تعداد گام‌هایی) را مشخص می‌کند که الگوریتم برای پیدا کردن جواب مسئله نیاز دارد،
به طوری که این زمان تابع اندازهٔ ورودی مسئله است.
\item[-]
بنابراین اگر ورودی یک مسئله 
\m{n}
 باشد و زمان لازم برای محاسبهٔ جواب مسئله توسط یک الگوریتم 
\m{f(n)}
باشد، می‌گوییم زمان محاسبه
\fn{1}{computation time}
یا زمان اجرا
\fn{2}{running time}
 یا پیچیدگی زمانی
\fn{3}{time complexity}
  الگوریتم از مرتبهٔ 
\m{f(n)}
است.
\item[-]
می‌توانیم نرخ رشد توابع
\fn{4}{growth rate of functions}
 مختلف را با یکدیگر مقایسه کنیم.
\end{itemize}

\end{frame}

\begin{frame}{مقایسه رشد توابع}

\begin{figure}[!ht]
\centering
\includestandalone[width=0.5\textwidth]{figs/chap01/complexity}
\label{fig:complexity}
\end{figure}

\end{frame}

\begin{frame}{مقایسه رشد توابع پیچیدگی}

\begin{itemize}\itmsep{2mm}
\item[-]
اگر هر گام در یک الگوریتم فقط یک میکروثانیه زمان ببرد، می‌توانیم زمان تقریبی محاسبه به ازای توابع رشد متفاوت را به صورت زیر با یکدیگر مقایسه کنیم.
\end{itemize}

\begin{center}
\begin{tabular}{c | c c c}
اندازهٔ $n$ 
 & 20 & 40 & 60 \\ \hline
تابع پیچیدگی $f(n)$ &  & &
\\
$n$ &
۰/‌۰۰۰۰۲ ثانیه &
۰/‌۰۰۰۰۴ ثانیه &
۰/‌۰۰۰۰۶ ثانیه \\
$n^2$ &
۰/‌۰۰۰۴ ثانیه &
۰/‌۰۰۱۶ ثانیه &
۰/‌۰۰۳۶ ثانیه \\
$n^3$ &
۰/‌۰۰۸ ثانیه &
۰/‌۰۶۴ ثانیه &
۰/‌۲۱۶ ثانیه \\
$n^5$ &
۳/۲ ثانیه &
۱/۷ دقیقه &
۱۳ دقیقه \\
$2^n$ &
۱ ثانیه &
۱۲/۷ روز &
۳۶۶ قرن \\
$3^n$ &
۵۸ دقیقه &
۳۸۵۵ قرن &
$\text{۱/۳} \times 10^{13}$ قرن 
\\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}{مثال : پیچیدگی زمانی الگوریتم سادهٔ کوتاهترین مسیر}
\begin{itemize}\itmsep{5mm}
\item[-]
در بدترین حالت همهٔ شهرها با یک مسیر به هم متصل شده‌اند.
\item[-]
در این صورت تنها تعداد همهٔ مسیرها از شهر
\m{c_x}
به شهر
\m{c_y}
با طول n
برابر است با
\m{(n-1)!}.
\item[-]
بنابراین تنها برای شمردن همهٔ مسیرهای با طول n و مقایسهٔ طول آنها به
\m{(n-1)!}
گام زمانی نیاز داریم.
\item[-]
رشد تابع
\m{n!}
از رشد تابع
\m{2^n}
نیز سریع تر است.
\item[-]
اگر بررسی هر مسیر فقط یک میکروثانیه زمان ببرد، برای شمارش و بررسی همهٔ مسیرها در مجموعه‌ای با تنها ۶۰ شهر به 
$\text{۲/۶} \times 10^{66}$
قرن زمان نیاز داریم.
($60 ! = \text{۸/۳} \times 10^{81}$)
\end{itemize}
\end{frame}

\begin{frame}{الگوریتم کوتاهترین مسیر دایکسترا}
\begin{itemize}\itmsep{5mm}
\item[-] 
الگوریتم کوتاهترین مسیر دایکسترا توسط ادسخر دایکسترا
\fn{1}{Edsger Dijkstra}
 در سال ۱۹۵۶ ابداع شد.
\item[-]
این الگوریتم از حافظه‌ای جانبی استفاده می‌کند و کوتاهترین مسیر را برای تمام زیر مسئله‌های مسئله اصلی پیدا می‌کند، یعنی:
\item[-]
با شروع از شهر 
 \m{c_x}
 این الگوریتم کوتاهترین مسیرها را از شهر
 \m{c_x}
 به تمام همسایه‌های این شهر محاسبه می‌کند و به همین ترتیب کوتاهترین مسیر از همسایه‌های
 \m{c_x}
 به همهٔ همسایه‌های آنها، الی آخر.
\item[-]
بدین ترتیب الگوریتم دایکسترا همهٔ کوتاهترین مسیرها را از شهر
\m{c_x}
به همهٔ شهرهای دیگر از جمله شهر
\m{c_y}
محاسبه می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{مثال: الگوریتم کوتاهترین مسیر دایکسترا}

\begin{figure}[!ht]
  \centering
 \only<1>{\includestandalone{figs/chap01/d1}}
 \only<2>{\includestandalone{figs/chap01/d2}}
 \only<3>{\includestandalone{figs/chap01/d3}}
  \only<4>{\includestandalone{figs/chap01/d4}}
  \only<5>{\includestandalone{figs/chap01/d5}}
  \only<6>{\includestandalone{figs/chap01/d6}}
  \only<7>{\includestandalone{figs/chap01/d7}}
  \only<8>{\includestandalone{figs/chap01/d8}}
  \label{fig:d1}
\end{figure}

\[
P =~\langle~c_1, \pause \pause c_2, \pause \pause c_3,\pause \pause 
c_4,  \pause c_5 ~\rangle
\]

\end{frame}

\begin{frame}{پیچیدگی زمانی الگوریتم کوتاهترین مسیر دایکسترا}
\begin{itemize}\itmsep{5mm}
\item[-]
هر شهر در یک گام باید بررسی شود و در بدترین حالت (حالتی که همهٔ شهرها به هم متصل باشند) به ازای هر شهر، همهٔ شهرهای دیگر بررسی می‌شوند.
\item[-]
بنابراین در صورتی که $n$ شهر وجود داشته باشد، پیچیدگی الگوریتم
$n^2$
است.
\item[-]
با استفاده از الگوریتم دایکسترا برای مجموعه‌ای از ۶۰ شهر به تنها ۰/‌۰۰۳۶ ثانیه زمان نیاز داریم.
\end{itemize}
\end{frame}